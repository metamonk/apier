# Deployment Guide

This guide covers setting up and managing the multi-environment CI/CD pipeline for the Zapier Triggers API.

## Quick Start

### For First-Time Setup

1. **AWS Amplify Console Setup**:
   ```bash
   # Open AWS Amplify Console
   open https://console.aws.amazon.com/amplify/
   ```

2. **Connect Repository**:
   - Click "New app" → "Host web app"
   - Select "GitHub" as provider
   - Authorize and select repository: `metamonk/apier`
   - Choose branches to deploy

3. **Configure Environments**:
   - **Production**: Connect `main` branch
   - **Development**: Connect `dev` branch
   - Amplify will auto-detect `amplify.yml` build settings

4. **Verify Build Settings**:
   The `amplify.yml` file is pre-configured with:
   - Backend deployment via `npx ampx pipeline-deploy`
   - Dependency caching for faster builds
   - Environment-specific resource isolation

## Environment Configuration

### Development Environment (`dev` branch)

**Purpose**: Active development, testing, and integration

**Workflow**:
```bash
# Switch to dev branch
git checkout dev

# Make your changes
# ... edit files ...

# Commit and push
git add .
git commit -m "feat: your feature description"
git push origin dev
```

**What Happens**:
1. GitHub triggers webhook to AWS Amplify
2. Amplify pulls latest `dev` branch code
3. Runs build commands from `amplify.yml`
4. Deploys backend resources with `-dev` environment suffix
5. Outputs unique API endpoints for dev environment

### Production Environment (`main` branch)

**Purpose**: Stable, production-ready releases

**Workflow**:
```bash
# After testing in dev, merge to main
git checkout main
git merge dev

# Push to trigger production deployment
git push origin main
```

**What Happens**:
1. GitHub triggers webhook to AWS Amplify
2. Amplify pulls latest `main` branch code
3. Runs build commands from `amplify.yml`
4. Deploys backend resources with `-prod` environment suffix
5. Outputs production API endpoints

## Deployment Process Details

### Amplify Build Phases

The `amplify.yml` file defines three phases:

1. **Backend Build**:
   ```yaml
   backend:
     phases:
       build:
         commands:
           - npm ci --cache .npm --prefer-offline
           - npx ampx pipeline-deploy --branch $AWS_BRANCH --app-id $AWS_APP_ID
   ```
   - Installs dependencies with caching
   - Deploys backend via Amplify Gen 2 pipeline
   - Uses branch name to determine environment

2. **Frontend Pre-Build**:
   ```yaml
   frontend:
     phases:
       preBuild:
         commands:
           - npm ci --cache .npm --prefer-offline
   ```
   - Installs dependencies for any frontend builds
   - Currently minimal since this is backend-only

3. **Frontend Build**:
   ```yaml
   frontend:
     phases:
       build:
         commands:
           - echo "No frontend build required - backend only deployment"
   ```
   - Placeholder for future frontend integration

### Environment Variables

Amplify automatically provides:
- `AWS_BRANCH` - Current branch name (main/dev)
- `AWS_APP_ID` - Amplify app identifier
- `AWS_REGION` - Deployment region

These are used by `ampx pipeline-deploy` to create environment-specific resources.

## Resource Naming Convention

Each environment gets isolated AWS resources with auto-generated names:

### Development (`dev` branch):
- DynamoDB: `zapier-triggers-events-{dev-stack-id}`
- Secret: `zapier-api-credentials-{dev-stack-id}`
- Lambda: Auto-generated by CDK

### Production (`main` branch):
- DynamoDB: `zapier-triggers-events-{prod-stack-id}`
- Secret: `zapier-api-credentials-{prod-stack-id}`
- Lambda: Auto-generated by CDK

## Post-Deployment Tasks

### 1. Get API Endpoints

After each deployment:

```bash
# Via Amplify Console
# → App → Branch → Backend resources → Click "TriggersApiUrl"

# Or via AWS CLI
aws cloudformation describe-stacks \
  --stack-name {stack-name} \
  --query 'Stacks[0].Outputs[?OutputKey==`TriggersApiUrl`].OutputValue' \
  --output text
```

### 2. Configure Secrets

Update environment-specific secrets:

```bash
# Get stack name from Amplify Console or CloudFormation
STACK_NAME="your-stack-name"

# Update secrets
aws secretsmanager update-secret \
  --secret-id zapier-api-credentials-${STACK_NAME} \
  --secret-string '{
    "zapier_api_key": "your-actual-api-key",
    "zapier_webhook_url": "https://hooks.zapier.com/your-webhook",
    "jwt_secret": "keep-auto-generated-value",
    "environment": "production"
  }'
```

### 3. Test API

```bash
# Get the Function URL from Amplify Console
API_URL="your-function-url"

# Health check
curl $API_URL

# View API docs
open ${API_URL}docs
```

## Monitoring Deployments

### Amplify Console

1. **Build Status**:
   - Go to Amplify Console → App → Branch
   - View real-time build logs
   - Check for errors in each phase

2. **Backend Resources**:
   - Click "Backend resources" tab
   - View all deployed CloudFormation stacks
   - Access output values (API URLs, ARNs)

### CloudFormation

Each deployment creates/updates a CloudFormation stack:

```bash
# List stacks
aws cloudformation list-stacks \
  --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE

# View stack events
aws cloudformation describe-stack-events \
  --stack-name {stack-name} \
  --max-items 20
```

### CloudWatch Logs

Monitor Lambda function logs:

```bash
# Find log group
aws logs describe-log-groups \
  --log-group-name-prefix /aws/lambda/

# Tail logs
aws logs tail /aws/lambda/{function-name} --follow
```

## Troubleshooting

### Build Failures

**Problem**: Amplify build fails with "npm install" errors

**Solution**:
```bash
# Verify package.json has all dependencies
npm install
npm test

# Check amplify.yml syntax
cat amplify.yml

# Review build logs in Amplify Console
```

### Deployment Timeouts

**Problem**: CloudFormation stack creation times out

**Solution**:
- Check AWS service quotas (Lambda, DynamoDB)
- Verify IAM permissions for Amplify service role
- Review CloudFormation events for specific resource failures

### Environment Mismatch

**Problem**: Changes don't appear in expected environment

**Solution**:
```bash
# Verify current branch
git branch

# Verify remote tracking
git remote -v
git branch -vv

# Force rebuild in Amplify Console
# → App → Branch → "Redeploy this version"
```

### Docker Build Failures

**Problem**: Lambda Docker image fails to build

**Solution**:
```bash
# Test Docker build locally
cd amplify/functions/api
docker build --platform linux/amd64 -t test-api .

# Verify Dockerfile
cat Dockerfile

# Check logs in Amplify Console build phase
```

## Rollback Procedures

### Quick Rollback via Amplify

1. Go to Amplify Console → App → Branch
2. View build history
3. Click on previous successful build
4. Click "Redeploy this version"

### Manual Rollback via Git

```bash
# Development rollback
git checkout dev
git reset --hard {previous-commit-sha}
git push --force origin dev

# Production rollback
git checkout main
git reset --hard {previous-commit-sha}
git push --force origin main
```

**⚠️ Warning**: Force pushing to `main` should be rare. Use with caution.

### CloudFormation Rollback

If deployment fails, CloudFormation automatically rolls back:
- View rollback events in CloudFormation Console
- Previous stack state is restored
- Resources are reverted to last stable version

## Best Practices

### Development Workflow

1. ✅ **Always develop on `dev` branch first**
2. ✅ **Test in dev environment before merging to main**
3. ✅ **Use feature branches for complex changes**
4. ✅ **Squash commits when merging to keep history clean**

### Deployment Strategy

1. ✅ **Review build logs for each deployment**
2. ✅ **Test API endpoints immediately after deployment**
3. ✅ **Update secrets after first deployment**
4. ✅ **Monitor CloudWatch logs for errors**

### Security

1. ✅ **Never commit secrets to Git**
2. ✅ **Use AWS Secrets Manager for credentials**
3. ✅ **Review IAM permissions regularly**
4. ✅ **Enable MFA for AWS Console access**

## CI/CD Pipeline Diagram

```
Developer                    GitHub                     AWS Amplify                   AWS Resources
    |                          |                            |                              |
    |-- git push dev -------->|                            |                              |
    |                          |-- webhook --------------->|                              |
    |                          |                            |-- Build (amplify.yml) ----->|
    |                          |                            |                              |
    |                          |                            |<-- Build Complete ----------|
    |                          |                            |                              |
    |                          |                            |-- Deploy Backend ---------->|
    |                          |                            |                              |-- Create/Update:
    |                          |                            |                              |   - Lambda
    |                          |                            |                              |   - DynamoDB
    |                          |                            |                              |   - Secrets Manager
    |                          |                            |                              |
    |                          |                            |<-- Deploy Complete ---------|
    |                          |                            |                              |
    |<-- Notification ---------|<-- Webhook ----------------|                              |
    |                          |                            |                              |
```

## Maintenance

### Regular Tasks

- **Weekly**: Review CloudWatch logs for errors
- **Monthly**: Audit IAM permissions and secrets
- **Quarterly**: Review and update dependencies
- **Yearly**: Evaluate new AWS services and features

### Cost Optimization

- Monitor AWS Cost Explorer for resource usage
- Consider Reserved Capacity for DynamoDB if usage is predictable
- Use Lambda provisioned concurrency only if cold starts are an issue
- Enable DynamoDB auto-scaling if traffic patterns vary

## Support

For issues or questions:
1. Check AWS Amplify Console build logs
2. Review CloudFormation stack events
3. Check CloudWatch logs for Lambda errors
4. Consult AWS Amplify documentation: https://docs.amplify.aws

## Blue-Green Deployment Strategy

### Overview

Blue-green deployment is a strategy that minimizes downtime and risk by running two identical production environments. At any time, only one environment (e.g., "blue") serves live production traffic, while the other (e.g., "green") is idle or running the new version.

### Benefits

- **Zero-downtime deployments**: Switch traffic instantly between environments
- **Quick rollback**: Revert to previous version by switching back to old environment
- **Testing in production-like environment**: Validate new version before switching traffic
- **Reduced risk**: New version is fully deployed and tested before receiving traffic

### Implementation Options for Zapier Triggers API

#### Option 1: AWS Amplify Multi-Branch Deployment (Current Setup)

**How it works:**
- Maintain two long-lived branches: `main` (blue) and `staging` (green)
- Deploy both environments simultaneously
- Use DNS or load balancer to switch traffic between environments

**Steps:**

1. **Setup Green Environment:**
   ```bash
   # Create staging branch from main
   git checkout -b staging main
   git push origin staging

   # In Amplify Console, connect staging branch
   # This creates a separate stack with isolated resources
   ```

2. **Deploy New Version to Green:**
   ```bash
   # Develop and test on dev branch first
   git checkout dev
   # ... make changes ...
   git push origin dev

   # When ready, merge to staging (green environment)
   git checkout staging
   git merge dev
   git push origin staging

   # Monitor deployment in Amplify Console
   ```

3. **Test Green Environment:**
   ```bash
   # Get staging API URL from Amplify Console
   STAGING_URL="https://your-staging-function-url.lambda-url.us-east-2.on.aws"

   # Run health checks
   curl $STAGING_URL/health

   # Test critical endpoints
   curl -X POST $STAGING_URL/token \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "username=api&password=your-api-key"

   # Run load tests if needed
   ```

4. **Switch Traffic (Manual DNS Update):**
   ```bash
   # Update your application to point to staging URL
   # OR update Route53 DNS records to point to staging

   # If using Route53 weighted routing:
   aws route53 change-resource-record-sets \
     --hosted-zone-id YOUR_ZONE_ID \
     --change-batch file://traffic-switch.json
   ```

5. **Monitor and Verify:**
   ```bash
   # Watch CloudWatch logs for new environment
   aws logs tail /aws/lambda/staging-function-name --follow

   # Check CloudWatch dashboard
   # Monitor error rates, latency, and throughput
   ```

6. **Promote Green to Blue:**
   ```bash
   # Once validated, update main branch
   git checkout main
   git merge staging
   git push origin main

   # Now main (blue) is the new version
   ```

#### Option 2: Lambda Aliases and Weighted Routing

**How it works:**
- Use Lambda aliases to represent blue and green versions
- Use weighted alias routing to gradually shift traffic
- Requires custom Lambda alias management

**Implementation:**

1. **Create Lambda Aliases:**
   ```typescript
   // Add to backend.ts
   const blueAlias = new lambda.Alias(stack, 'BlueAlias', {
     aliasName: 'blue',
     version: triggersApiFunction.currentVersion,
   });

   const greenAlias = new lambda.Alias(stack, 'GreenAlias', {
     aliasName: 'green',
     version: triggersApiFunction.currentVersion,
   });
   ```

2. **Deploy New Version to Green:**
   ```bash
   # Deploy changes
   npx ampx pipeline-deploy --branch main

   # Update green alias to new version
   aws lambda update-alias \
     --function-name your-function-name \
     --name green \
     --function-version $NEW_VERSION
   ```

3. **Gradually Shift Traffic:**
   ```bash
   # Start with 10% traffic to green
   aws lambda update-alias \
     --function-name your-function-name \
     --name prod \
     --routing-config AdditionalVersionWeights="{\"green\":0.1}"

   # Monitor CloudWatch metrics
   # If stable, increase to 50%
   aws lambda update-alias \
     --function-name your-function-name \
     --name prod \
     --routing-config AdditionalVersionWeights="{\"green\":0.5}"

   # Finally, switch 100% to green
   aws lambda update-alias \
     --function-name your-function-name \
     --name prod \
     --function-version $GREEN_VERSION
   ```

#### Option 3: AWS CodeDeploy with Lambda

**How it works:**
- Use CodeDeploy to automate traffic shifting
- Supports canary, linear, and all-at-once deployment types
- Automatic rollback on CloudWatch alarms

**Setup (requires additional configuration):**

1. **Add CodeDeploy to backend.ts:**
   ```typescript
   import * as codedeploy from 'aws-cdk-lib/aws-codedeploy';

   // Create deployment group
   const deploymentGroup = new codedeploy.LambdaDeploymentGroup(stack, 'DeploymentGroup', {
     alias: blueAlias,
     deploymentConfig: codedeploy.LambdaDeploymentConfig.CANARY_10PERCENT_5MINUTES,
     alarms: [errorAlarm, durationAlarm], // Auto-rollback on alarms
   });
   ```

2. **Deployment Types:**
   - **AllAtOnce**: Immediate switch (traditional blue-green)
   - **Canary10Percent5Minutes**: 10% for 5 min, then 100%
   - **Linear10PercentEvery3Minutes**: Gradual shift over 30 minutes

### Rollback Procedures

#### Quick Rollback (Amplify)

1. **Via Amplify Console:**
   - Go to Amplify Console → App → Branch
   - Find previous successful deployment
   - Click "Redeploy this version"

2. **Via Git:**
   ```bash
   # Revert to previous commit
   git revert HEAD
   git push origin main

   # Or force rollback (use with caution)
   git reset --hard {previous-commit}
   git push --force origin main
   ```

#### Instant Rollback (Blue-Green)

```bash
# If using multi-branch: Switch DNS back to blue environment
# If using Lambda aliases: Point prod alias back to blue version
aws lambda update-alias \
  --function-name your-function-name \
  --name prod \
  --function-version $BLUE_VERSION
```

### Automated Rollback Triggers

The monitoring setup includes automatic rollback triggers:

**CloudWatch Alarms configured:**
1. Error rate > 10 errors in 10 minutes
2. Average duration > 10 seconds
3. Any throttling events
4. DynamoDB throttling

**To enable automatic rollback:**
1. Use CodeDeploy with Lambda (Option 3 above)
2. Configure alarms as rollback triggers
3. CodeDeploy will automatically revert on alarm

**Manual monitoring approach:**
```bash
# Create CloudWatch alarm that triggers SNS
# SNS can trigger Lambda function to execute rollback
# Or use SNS to alert team for manual rollback
```

### Best Practices

1. **Always test in green before switching:**
   - Run full integration test suite
   - Perform smoke tests on critical paths
   - Load test to verify performance

2. **Monitor closely during switchover:**
   - Watch CloudWatch dashboard
   - Monitor X-Ray traces for errors
   - Check application logs

3. **Have rollback plan ready:**
   - Document rollback steps
   - Test rollback procedure in dev environment
   - Keep previous version running until validated

4. **Use gradual traffic shifting:**
   - Start with 10% traffic to new version
   - Monitor for 15-30 minutes
   - Gradually increase if stable

5. **Maintain database compatibility:**
   - Ensure DB schema changes are backward compatible
   - Test with both blue and green versions
   - Use feature flags for breaking changes

### Testing Blue-Green Deployment

**Dry run in dev environment:**

```bash
# Create test branches
git checkout -b blue-test
git checkout -b green-test

# Deploy both
# Test switching between them
# Verify rollback works

# Once validated, apply to production
```

## Next Steps

After completing initial setup:
1. Deploy to `dev` branch first to test pipeline
2. Verify dev environment resources in AWS Console
3. Update secrets for dev environment
4. Test API endpoints in dev
5. Merge to `main` and deploy production
6. Configure monitoring and alerts
7. Set up blue-green deployment strategy (choose one of the options above)
8. Test deployment and rollback procedures
